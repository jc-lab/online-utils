<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAR to Markdown Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.min.js"></script>
    <script src="./har-parser-worker.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 30px 40px;
            text-align: center;
        }

        .header h1 {
            color: white;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
        }

        .main-content {
            padding: 40px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            align-items: start;
        }

        .upload-section, .filter-section, .output-section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .upload-section:hover, .filter-section:hover, .output-section:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-drop {
            border: 3px dashed #4facfe;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-drop:hover {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.2) 0%, rgba(0, 242, 254, 0.2) 100%);
            transform: scale(1.02);
        }

        .file-drop.drag-over {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3) 0%, rgba(0, 242, 254, 0.3) 100%);
            border-color: #00f2fe;
        }

        .file-input {
            display: none;
        }

        .filter-group {
            margin-bottom: 25px;
        }

        .filter-label {
            display: block;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
        }

        .filter-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .filter-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            background: #f8fafc;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4facfe;
        }

        .request-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            background: #f8fafc;
        }

        .request-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
            transition: background-color 0.2s ease;
        }

        .request-item:hover {
            background: rgba(79, 172, 254, 0.05);
        }

        .request-item:last-child {
            border-bottom: none;
        }

        .method-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
            min-width: 60px;
            text-align: center;
        }

        .method-GET { background: #10b981; }
        .method-POST { background: #3b82f6; }
        .method-PUT { background: #f59e0b; }
        .method-DELETE { background: #ef4444; }
        .method-PATCH { background: #8b5cf6; }

        .url-info {
            flex: 1;
            min-width: 0;
        }

        .url-path {
            font-weight: 500;
            color: #2d3748;
            word-break: break-all;
        }

        .url-host {
            font-size: 0.9rem;
            color: #718096;
        }

        .markdown-output {
            grid-column: 1 / -1;
            background: #1a202c;
            color: #e2e8f0;
            border-radius: 15px;
            padding: 30px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .copy-button {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .copy-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 172, 254, 0.3);
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%);
            padding: 15px 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4facfe;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #718096;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #4facfe;
            font-size: 1.1rem;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 30px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .checkbox-group {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>ğŸ”„ HAR to Markdown Converter</h1>
                <p>Chrome HAR íŒŒì¼ì„ ë¶„ì„í•˜ê³  Markdown í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤</p>
            </div>

            <div class="main-content">
                <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
                <div class="upload-section">
                    <h2 class="section-title">ğŸ“ HAR íŒŒì¼ ì—…ë¡œë“œ</h2>
                    <div 
                        class="file-drop"
                        :class="{ 'drag-over': dragOver }"
                        @click="$refs.fileInput.click()"
                        @dragover.prevent="dragOver = true"
                        @dragleave.prevent="dragOver = false"
                        @drop.prevent="handleFileDrop"
                    >
                        <div v-if="!harData">
                            <div style="font-size: 3rem; margin-bottom: 15px;">ğŸ“</div>
                            <p style="font-size: 1.2rem; font-weight: 600; color: #4facfe; margin-bottom: 10px;">
                                HAR íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ
                            </p>
                            <p style="color: #718096;">Chrome DevTools > Network > Export HAR</p>
                        </div>
                        <div v-else>
                            <div style="font-size: 3rem; margin-bottom: 15px;">âœ…</div>
                            <p style="font-size: 1.2rem; font-weight: 600; color: #10b981;">
                                HAR íŒŒì¼ ë¡œë“œ ì™„ë£Œ
                            </p>
                            <p style="color: #718096;">{{ harData.log.entries.length }}ê°œì˜ ìš”ì²­ ë°œê²¬</p>
                        </div>
                    </div>
                    <input 
                        ref="fileInput"
                        type="file"
                        accept=".har"
                        class="file-input"
                        @change="handleFileSelect"
                    >

                    <!-- í†µê³„ ì •ë³´ -->
                    <div v-if="harData" class="stats">
                        <div class="stat-item">
                            <div class="stat-number">{{ harData.log.entries.length }}</div>
                            <div class="stat-label">ì „ì²´ ìš”ì²­</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">{{ filteredRequests.length }}</div>
                            <div class="stat-label">í•„í„°ë§ëœ ìš”ì²­</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">{{ selectedRequests.length }}</div>
                            <div class="stat-label">ì„ íƒëœ ìš”ì²­</div>
                        </div>
                    </div>
                </div>

                <!-- í•„í„°ë§ ì„¹ì…˜ -->
                <div v-if="harData" class="filter-section">
                    <h2 class="section-title">ğŸ” í•„í„°ë§ ì˜µì…˜</h2>
                    
                    <div class="filter-group">
                        <label class="filter-label">URL íŒ¨í„´ (ì •ê·œì‹)</label>
                        <input 
                            v-model="filters.urlPattern"
                            type="text"
                            class="filter-input"
                            placeholder="ì˜ˆ: .*api.*"
                        >
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">Content Type</label>
                        <input 
                            v-model="filters.contentType"
                            type="text"
                            class="filter-input"
                            placeholder="ì˜ˆ: application/json"
                        >
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">HTTP ë©”ì„œë“œ</label>
                        <div class="checkbox-group">
                            <div v-for="method in availableMethods" :key="method" class="checkbox-item">
                                <input
                                    type="checkbox"
                                    :id="'method-' + method"
                                    v-model="filters.methods"
                                    :value="method"
                                >
                                <label :for="'method-' + method">{{ method }}</label>
                            </div>
                        </div>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">ë¦¬ì†ŒìŠ¤ íƒ€ì…</label>
                        <div class="checkbox-group">
                            <div v-for="type in ['Fetch/XHR', 'Doc', 'CSS', 'JS', 'Font', 'Img', 'Media', 'Manifest', 'Socket', 'Wasm', 'Other']" :key="type" class="checkbox-item">
                                <input
                                    type="checkbox"
                                    :id="'type-' + type"
                                    v-model="filters.resourceTypes"
                                    :value="type"
                                >
                                <label :for="'type-' + type">{{ type }}</label>
                            </div>
                        </div>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">ì¶œë ¥í•  í—¤ë” ì„ íƒ</label>
                        <div class="checkbox-group">
                            <div v-for="header in availableHeaders" :key="header" class="checkbox-item">
                                <input 
                                    type="checkbox"
                                    :id="'header-' + header"
                                    v-model="selectedHeaders"
                                    :value="header"
                                >
                                <label :for="'header-' + header">{{ header }}</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ìš”ì²­ ëª©ë¡ ì„ íƒ ì„¹ì…˜ -->
                <div v-if="filteredRequests.length > 0" class="upload-section">
                    <h2 class="section-title">ğŸ“‹ ìš”ì²­ ëª©ë¡</h2>
                    <div style="margin-bottom: 15px;">
                        <label class="checkbox-item" style="padding: 10px; background: #f8fafc; border-radius: 10px;">
                            <input
                                type="checkbox"
                                :id="'select-all'"
                                :checked="selectedRequests.length === filteredRequests.length && filteredRequests.length > 0"
                                @change="toggleSelectAll"
                            >
                            <label :for="'select-all'" style="font-weight: 600;">ëª¨ë“  ìš”ì²­ ì„ íƒ/í•´ì œ</label>
                        </label>
                    </div>
                    <div class="request-list">
                        <div v-for="(request, index) in filteredRequests" :key="index" class="request-item">
                            <input 
                                type="checkbox"
                                :id="'request-' + index"
                                v-model="selectedRequests"
                                :value="request"
                                @change="generateMarkdown"
                            >
                            <span :class="'method-badge method-' + request.method">
                                {{ request.method }}
                            </span>
                            <div class="url-info">
                                <div class="url-path">{{ getUrlPath(request.url) }}</div>
                                <div class="url-host">{{ getUrlHost(request.url) }}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Markdown ì¶œë ¥ ì„¹ì…˜ -->
                <div v-if="markdownOutput" class="output-section">
                    <h2 class="section-title">ğŸ“ Markdown ì¶œë ¥</h2>
                    <button @click="copyToClipboard" class="copy-button">ğŸ“‹ í´ë¦½ë³´ë“œì— ë³µì‚¬</button>
                    <div class="markdown-output">{{ markdownOutput }}</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    harData: null,
                    dragOver: false,
                    availableMethods: [],
                    availableHeaders: [],
                    filters: {
                        urlPattern: '',
                        contentType: '',
                        methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
                        // resourceTypes: ['Fetch/XHR', 'Doc', 'CSS', 'JS', 'Font', 'Img', 'Media', 'Manifest', 'Socket', 'Wasm', 'Other'],
                        resourceTypes: ['Fetch/XHR', 'Doc', 'Other'],
                    },
                    selectedHeaders: ['Content-Type', 'Authorization', 'Accept', 'User-Agent'],
                    selectedRequests: [],
                    markdownOutput: ''
                }
            },
            computed: {
                filteredRequests() {
                    if (!this.harData) return [];
                    
                    let requests = this.harData.log.entries.map(entry => ({
                        method: entry.request.method,
                        url: entry.request.url,
                        headers: entry.request.headers,
                        responseHeaders: entry.response.headers,
                        status: entry.response.status,
                        statusText: entry.response.statusText,
                        postData: entry.request.postData,
                        responseContent: entry.response.content,
                        time: entry.time,
                        resourceType: this.getResourceType({
                            responseHeaders: entry.response.headers
                        })
                    }));

                    // URL íŒ¨í„´ í•„í„°
                    if (this.filters.urlPattern) {
                        try {
                            const regex = new RegExp(this.filters.urlPattern, 'i');
                            requests = requests.filter(req => regex.test(req.url));
                        } catch (e) {
                            // ì˜ëª»ëœ ì •ê·œì‹ì¸ ê²½ìš° ë¬´ì‹œ
                        }
                    }

                    // Content Type í•„í„°
                    if (this.filters.contentType) {
                        requests = requests.filter(req => {
                            const contentType = req.headers.find(h => h.name.toLowerCase() === 'content-type');
                            return contentType && contentType.value.toLowerCase().includes(this.filters.contentType.toLowerCase());
                        });
                    }

                    requests = requests.filter(req => 
                        // ë©”ì„œë“œ í•„í„°
                        this.filters.methods.includes(req.method) && 
                        // ë¦¬ì†ŒìŠ¤ íƒ€ì… í•„í„°
                        this.filters.resourceTypes.includes(req.resourceType)
                    );

                    return requests;
                }
            },
            watch: {
                filteredRequests: {
                    handler(newRequests) {
                        // í•„í„°ë§ì´ ë³€ê²½ë˜ë©´ ì„ íƒëœ ìš”ì²­ë“¤ ì¤‘ ë” ì´ìƒ í•„í„°ì— ë§ì§€ ì•ŠëŠ” ê²ƒë“¤ ì œê±°
                        this.selectedRequests = this.selectedRequests.filter(selected => 
                            newRequests.some(filtered => 
                                filtered.url === selected.url && filtered.method === selected.method
                            )
                        );
                        this.generateMarkdown();
                    },
                    deep: true
                },
                selectedHeaders() {
                    this.generateMarkdown();
                }
            },
            methods: {
                handleFileDrop(e) {
                    this.dragOver = false;
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadHarFile(files[0]);
                    }
                },
                handleFileSelect(e) {
                    if (e.target.files.length > 0) {
                        this.loadHarFile(e.target.files[0]);
                    }
                },
                async loadHarFile(file) {
                    const text = await file.text();

                    try {
                        if (window.Worker) {
                            // Web Worker ì‚¬ìš©
                            const worker = new Worker('./har-parser-worker.js');
                            worker.postMessage({ harText: text });
                            worker.onmessage = (e) => {
                                const { success, harData, availableMethods, availableHeaders, error } = e.data;
                                if (success) {
                                    this.harData = harData;
                                    this.availableMethods = availableMethods;
                                    this.availableHeaders = availableHeaders;
                                    // ì´ˆê¸°ì—ëŠ” ëª¨ë“  ìš”ì²­ì„ ì„ íƒ
                                    this.$nextTick(() => {
                                        this.selectedRequests = [...this.filteredRequests];
                                        this.generateMarkdown();
                                    });
                                } else {
                                    alert('HAR íŒŒì¼ì„ íŒŒì‹±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error);
                                }
                                worker.terminate();
                            };
                            worker.onerror = (error) => {
                                alert('Worker ì˜¤ë¥˜: ' + error.message);
                                worker.terminate();
                            };
                            return;
                        }
                    } catch (error) {
                        console.log('worker failed:', error);
                    }

                    // Workerë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìœ¼ë©´ ì§ì ‘ í•¨ìˆ˜ í˜¸ì¶œ
                    const result = window.parseHar(text);
                    console.log('result: ', result);
                    if (result.success) {
                        this.harData = result.harData;
                        this.availableMethods = result.availableMethods;
                        this.availableHeaders = result.availableHeaders;
                        // ì´ˆê¸°ì—ëŠ” ëª¨ë“  ìš”ì²­ì„ ì„ íƒ
                        this.$nextTick(() => {
                            this.selectedRequests = [...this.filteredRequests];
                            this.generateMarkdown();
                        });
                    } else {
                        alert('HAR íŒŒì¼ì„ íŒŒì‹±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + result.error);
                    }
                },
                getUrlPath(url) {
                    try {
                        const urlObj = new URL(url);
                        return urlObj.pathname + urlObj.search;
                    } catch {
                        return url;
                    }
                },
                getUrlHost(url) {
                    try {
                        const urlObj = new URL(url);
                        return urlObj.host;
                    } catch {
                        return '';
                    }
                },
                getResourceType(request) {
                    // Content-Typeìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ íƒ€ì… ê²°ì •
                    const contentType = request.responseHeaders.find(h =>
                        h.name.toLowerCase() === 'content-type'
                    );
                    if (!contentType) return 'Other';

                    const type = contentType.value.toLowerCase();

                    if (type.includes('text/html')) return 'Doc';
                    if (type.includes('text/css')) return 'CSS';
                    if (type.includes('text/javascript') || type.includes('application/javascript')) return 'JS';
                    if (type.includes('font/') || type.includes('application/font-')) return 'Font';
                    if (type.includes('image/')) return 'Img';
                    if (type.includes('video/') || type.includes('audio/')) return 'Media';
                    if (type.includes('application/manifest+json')) return 'Manifest';
                    if (type.includes('application/wasm')) return 'Wasm';
                    if (type.includes('websocket')) return 'Socket';

                    // Fetch/XHR: JSON, XML, plain text ë“± API ìš”ì²­ìœ¼ë¡œ ê°€ì •
                    if (type.includes('application/json') || type.includes('application/xml') || type.includes('text/plain')) {
                        return 'Fetch/XHR';
                    }

                    return 'Other';
                },
                toggleSelectAll() {
                    if (this.selectedRequests.length === this.filteredRequests.length) {
                        // ëª¨ë‘ ì„ íƒëœ ìƒíƒœë©´ ëª¨ë‘ í•´ì œ
                        this.selectedRequests = [];
                    } else {
                        // ì•„ë‹ˆë©´ ëª¨ë‘ ì„ íƒ
                        this.selectedRequests = [...this.filteredRequests];
                    }
                    this.generateMarkdown();
                },
                generateMarkdown() {
                    if (this.selectedRequests.length === 0) {
                        this.markdownOutput = '';
                        return;
                    }

                    let markdown = '# HTTP Requests Documentation\n\n';
                    
                    this.selectedRequests.forEach((request, index) => {
                        markdown += `## ${index + 1}. ${request.method} ${request.url}\n\n`;
                        
                        markdown += `**Status:** ${request.status} ${request.statusText}\n\n`;
                        
                        // Request Headers
                        const requestHeaders = request.headers.filter(h => 
                            this.selectedHeaders.some(selected => 
                                selected.toLowerCase() === h.name.toLowerCase()
                            )
                        );
                        if (requestHeaders.length > 0) {
                            markdown += `### Request Headers\n\n`;
                            requestHeaders.forEach(header => {
                                markdown += `- **${header.name}:** ${header.value}\n`;
                            });
                            markdown += '\n';
                        }

                        // Response Headers
                        const responseHeaders = request.responseHeaders.filter(h => 
                            this.selectedHeaders.some(selected => 
                                selected.toLowerCase() === h.name.toLowerCase()
                            )
                        );
                        if (responseHeaders.length > 0) {
                            markdown += `### Response Headers\n\n`;
                            responseHeaders.forEach(header => {
                                markdown += `- **${header.name}:** ${header.value}\n`;
                            });
                            markdown += '\n';
                        }

                        // Request Body
                        if (request.postData && request.postData.text) {
                            markdown += `### Request Body\n\n`;
                            markdown += '```json\n';
                            try {
                                const jsonData = JSON.parse(request.postData.text);
                                markdown += JSON.stringify(jsonData, null, 2);
                            } catch {
                                markdown += request.postData.text;
                            }
                            markdown += '\n```\n\n';
                        }

                        // Response Body (ì²« 1000ìë§Œ)
                        if (request.responseContent && request.responseContent.text) {
                            markdown += `### Response Body\n\n`;
                            markdown += '```json\n';
                            let responseText = request.responseContent.text;
                            responseText = responseText;
                            try {
                                const jsonData = JSON.parse(request.responseContent.text);
                                const truncatedJson = JSON.stringify(jsonData, null, 2);
                                markdown += truncatedJson;
                            } catch {
                                markdown += responseText;
                            }
                            markdown += '\n```\n\n';
                        }

                        markdown += '---\n\n';
                    });

                    this.markdownOutput = markdown;
                },
                async copyToClipboard() {
                    try {
                        await navigator.clipboard.writeText(this.markdownOutput);
                        // ê°„ë‹¨í•œ í”¼ë“œë°±
                        const button = event.target;
                        const originalText = button.textContent;
                        button.textContent = 'âœ… ë³µì‚¬ë¨!';
                        setTimeout(() => {
                            button.textContent = originalText;
                        }, 2000);
                    } catch (error) {
                        alert('í´ë¦½ë³´ë“œ ë³µì‚¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    }
                }
            }
        }).mount('#app');
    </script>
</body>
</html>